#!/usr/bin/env node
/**
 * Lighthouse Batch Runner (Production Server)
 *
 * Runs Lighthouse against a list of URLs (typically public routes) and writes
 * JSON+HTML reports into `frontend/perf-results/`.
 *
 * Inputs:
 *  - perf-results/lighthouse-urls-public.txt (generated by `scripts/perf-inventory.js`)
 *
 * Environment:
 *  - PERF_BASE_URL   (optional) e.g. http://localhost:3000 (rewrites URL origins)
 *  - PERF_PRESETS    (optional) comma-separated, default: desktop,mobile
 *  - PERF_RUNS       (optional) integer, default: 1 (runs per URL per preset; median score selected)
 */

const { spawnSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const PERF_RESULTS_DIR = path.join(__dirname, '../perf-results');
const URLS_FILE = path.join(PERF_RESULTS_DIR, 'lighthouse-urls-public.txt');

function die(message) {
  console.error(`[perf] ❌ ${message}`);
  process.exit(1);
}

function info(message) {
  console.log(`[perf] ${message}`);
}

function safeSlugFromUrl(urlString) {
  let url;
  try {
    url = new URL(urlString);
  } catch {
    return 'page';
  }

  const pathname = url.pathname || '/';
  if (pathname === '/' || pathname === '') return 'home';

  const slug = pathname
    .replace(/^\//, '')
    .replace(/[^a-z0-9]+/gi, '-')
    .replace(/^-+|-+$/g, '')
    .toLowerCase();

  return slug || 'page';
}

function rewriteOrigin(urlString, baseUrl) {
  if (!baseUrl) return urlString;
  let original;
  let base;
  try {
    original = new URL(urlString);
    base = new URL(baseUrl);
  } catch {
    return urlString;
  }
  const rewritten = new URL(original.pathname + original.search + original.hash, base);
  return rewritten.toString();
}

function reportJsonPath(outputBase) {
  return `${outputBase}.report.json`;
}

function reportHtmlPath(outputBase) {
  return `${outputBase}.report.html`;
}

function removeIfExists(filePath) {
  if (fs.existsSync(filePath)) fs.rmSync(filePath, { force: true });
}

function lighthouseRun({ url, preset, outputBase }) {
  // Lighthouse CLI will create `${outputBase}.report.json` and `.report.html`
  const args = [
    url,
    '--output=json,html',
    `--output-path=${outputBase}`,
    '--quiet',
    `--chrome-flags=--headless --no-sandbox`,
  ];

  // Lighthouse v12 supports presets like "desktop" and defaults to mobile.
  // Treat "mobile" as the default config.
  if (preset && preset.toLowerCase() !== 'mobile') {
    args.push(`--preset=${preset}`);
  }

  // If supported by the installed Lighthouse version, this helps make intent explicit.
  if (preset && preset.toLowerCase() === 'mobile') {
    args.push('--form-factor=mobile');
  }

  const result = spawnSync('npx', ['lighthouse', ...args], {
    cwd: path.join(__dirname, '..'),
    stdio: 'inherit',
    shell: true,
  });

  return result.status === 0;
}

function readPerfScore(jsonFilePath) {
  const data = JSON.parse(fs.readFileSync(jsonFilePath, 'utf-8'));
  const score = data?.categories?.performance?.score;
  if (typeof score !== 'number') return null;
  return Math.round(score * 100);
}

function main() {
  if (!fs.existsSync(PERF_RESULTS_DIR)) {
    fs.mkdirSync(PERF_RESULTS_DIR, { recursive: true });
  }

  if (!fs.existsSync(URLS_FILE)) {
    die(`Missing URLs file: ${URLS_FILE}. Run: node scripts/perf-inventory.js`);
  }

  const baseUrl = process.env.PERF_BASE_URL || '';
  const presets = (process.env.PERF_PRESETS || 'desktop,mobile')
    .split(',')
    .map(s => s.trim())
    .filter(Boolean);

  const runs = Math.max(1, parseInt(process.env.PERF_RUNS || '1', 10) || 1);

  const urls = fs
    .readFileSync(URLS_FILE, 'utf-8')
    .split(/\r?\n/)
    .map(s => s.trim())
    .filter(Boolean)
    .map(u => rewriteOrigin(u, baseUrl));

  if (urls.length === 0) {
    die('No URLs found in lighthouse-urls-public.txt');
  }

  const startedAt = new Date().toISOString();
  info(`Running Lighthouse for ${urls.length} URLs × ${presets.length} preset(s) × ${runs} run(s)`);
  if (baseUrl) info(`Rewriting URL origin to: ${baseUrl}`);

  const summary = {
    generated: new Date().toISOString(),
    startedAt,
    baseUrl: baseUrl || null,
    presets,
    runs,
    urlsCount: urls.length,
    results: [],
  };

  for (const preset of presets) {
    info(`Preset: ${preset}`);
    for (const url of urls) {
      const slug = safeSlugFromUrl(url);
      const finalBase = path.join(PERF_RESULTS_DIR, `lighthouse-prod-${preset}-${slug}`);

      // Clean any previous final output
      removeIfExists(reportJsonPath(finalBase));
      removeIfExists(reportHtmlPath(finalBase));

      const runOutcomes = [];

      for (let i = 1; i <= runs; i++) {
        const tmpBase = `${finalBase}-run${i}`;
        removeIfExists(reportJsonPath(tmpBase));
        removeIfExists(reportHtmlPath(tmpBase));

        info(`  ${url} (run ${i}/${runs})`);
        const ok = lighthouseRun({ url, preset, outputBase: tmpBase });
        const jsonPath = reportJsonPath(tmpBase);

        if (!ok || !fs.existsSync(jsonPath)) {
          runOutcomes.push({ ok: false, score: null, base: tmpBase });
          continue;
        }

        const score = readPerfScore(jsonPath);
        runOutcomes.push({ ok: true, score, base: tmpBase });
      }

      const successful = runOutcomes.filter(r => r.ok && typeof r.score === 'number');
      if (successful.length === 0) {
        summary.results.push({ url, preset, slug, ok: false, selectedScore: null });
        info(`    ❌ Failed: ${url}`);
        // cleanup temp files
        for (const r of runOutcomes) {
          removeIfExists(reportJsonPath(r.base));
          removeIfExists(reportHtmlPath(r.base));
        }
        continue;
      }

      // Pick median by performance score
      successful.sort((a, b) => a.score - b.score);
      const selected = successful[Math.floor(successful.length / 2)];

      // Move selected artifacts to finalBase
      fs.renameSync(reportJsonPath(selected.base), reportJsonPath(finalBase));
      fs.renameSync(reportHtmlPath(selected.base), reportHtmlPath(finalBase));

      // Cleanup remaining run artifacts
      for (const r of runOutcomes) {
        removeIfExists(reportJsonPath(r.base));
        removeIfExists(reportHtmlPath(r.base));
      }

      summary.results.push({
        url,
        preset,
        slug,
        ok: true,
        selectedScore: selected.score,
        reportJson: path.relative(path.join(__dirname, '..'), reportJsonPath(finalBase)).replace(/\\/g, '/'),
        reportHtml: path.relative(path.join(__dirname, '..'), reportHtmlPath(finalBase)).replace(/\\/g, '/'),
      });

      info(`    ✓ Saved: ${path.basename(finalBase)} (perf ${selected.score})`);
    }
  }

  summary.finishedAt = new Date().toISOString();
  const summaryPath = path.join(PERF_RESULTS_DIR, 'lighthouse-prod-batch-summary.json');
  fs.writeFileSync(summaryPath, JSON.stringify(summary, null, 2));
  info(`Batch summary: ${summaryPath}`);
}

main();
